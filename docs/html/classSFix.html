<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FixMath: SFix&lt; NI, NF, RANGE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FixMath
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSFix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SFix&lt; NI, NF, RANGE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="FixMath_8h_source.html">FixMath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c98bb108b044af13a6329142c7b2de6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a0c98bb108b044af13a6329142c7b2de6">SFix</a> ()</td></tr>
<tr class="separator:a0c98bb108b044af13a6329142c7b2de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b24255334b013518c060354dad8128"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a29b24255334b013518c060354dad8128">SFix</a> (float fl)</td></tr>
<tr class="separator:a29b24255334b013518c060354dad8128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af205019d40489f55d3be4ae1ffe603c5"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#af205019d40489f55d3be4ae1ffe603c5">SFix</a> (double fl)</td></tr>
<tr class="separator:af205019d40489f55d3be4ae1ffe603c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae677662a0546de5535c93121e7bc1762"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae677662a0546de5535c93121e7bc1762"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#ae677662a0546de5535c93121e7bc1762">SFix</a> (T value, bool as_raw=false)</td></tr>
<tr class="separator:ae677662a0546de5535c93121e7bc1762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1a7033339c03de9ceab22962740ed9"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a2e1a7033339c03de9ceab22962740ed9"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a2e1a7033339c03de9ceab22962740ed9">SFix</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;sf)</td></tr>
<tr class="separator:a2e1a7033339c03de9ceab22962740ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164116927fa8b7664a7a4423efc50e96"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a164116927fa8b7664a7a4423efc50e96"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a164116927fa8b7664a7a4423efc50e96">SFix</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;uf)</td></tr>
<tr class="separator:a164116927fa8b7664a7a4423efc50e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6897e22fd904f54fdb7555b7bee852f6"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a6897e22fd904f54fdb7555b7bee852f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a6897e22fd904f54fdb7555b7bee852f6">operator+</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a6897e22fd904f54fdb7555b7bee852f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac991db0bee7ebb63e091582d41e9c766"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ac991db0bee7ebb63e091582d41e9c766"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#ac991db0bee7ebb63e091582d41e9c766">operator+</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op2) const</td></tr>
<tr class="separator:ac991db0bee7ebb63e091582d41e9c766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eabdb5d47e38190bf7d25430c7a8256"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a8eabdb5d47e38190bf7d25430c7a8256"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a8eabdb5d47e38190bf7d25430c7a8256">operator-</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a8eabdb5d47e38190bf7d25430c7a8256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecff8ee0cac43d3262f1453b03c17fd5"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:aecff8ee0cac43d3262f1453b03c17fd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#aecff8ee0cac43d3262f1453b03c17fd5">operator-</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:aecff8ee0cac43d3262f1453b03c17fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72d489b35d6ec78315735a0a411b39a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; NF, RANGE+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#ae72d489b35d6ec78315735a0a411b39a">operator-</a> () const</td></tr>
<tr class="separator:ae72d489b35d6ec78315735a0a411b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b81f170bb1348644459843c23dc0c6"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a25b81f170bb1348644459843c23dc0c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a25b81f170bb1348644459843c23dc0c6">operator*</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a25b81f170bb1348644459843c23dc0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0378525fe44b041e160eb32038bf30bf"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a0378525fe44b041e160eb32038bf30bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a0378525fe44b041e160eb32038bf30bf">operator*</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op2) const</td></tr>
<tr class="separator:a0378525fe44b041e160eb32038bf30bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02cc3a7746ce0550428095d8cba9eba"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NF, NI &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#ac02cc3a7746ce0550428095d8cba9eba">invFast</a> () const</td></tr>
<tr class="separator:ac02cc3a7746ce0550428095d8cba9eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77192383382e2ba7496c614db81343"><td class="memTemplParams" colspan="2">template&lt;int8_t _NF&gt; </td></tr>
<tr class="memitem:a9a77192383382e2ba7496c614db81343"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NF, _NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a9a77192383382e2ba7496c614db81343">inv</a> () const</td></tr>
<tr class="separator:a9a77192383382e2ba7496c614db81343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca66653e6de4958b0ccb22b644f66e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NF, FixMathPrivate::FM_min(NI *2+NF, 63-NF)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a35ca66653e6de4958b0ccb22b644f66e">invFull</a> () const</td></tr>
<tr class="separator:a35ca66653e6de4958b0ccb22b644f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7937916cb7c7aae5fbb33165df113445"><td class="memTemplParams" colspan="2">template&lt;int8_t _NF = FixMathPrivate::FM_min(NI*2+NF-1,63-NF)&gt; </td></tr>
<tr class="memitem:a7937916cb7c7aae5fbb33165df113445"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NF, _NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a7937916cb7c7aae5fbb33165df113445">invAccurate</a> () const</td></tr>
<tr class="separator:a7937916cb7c7aae5fbb33165df113445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b7f1ecb5c41cdd95ad2f7105b9cdf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a660b7f1ecb5c41cdd95ad2f7105b9cdf">operator&gt;&gt;</a> (const int8_t op) const</td></tr>
<tr class="separator:a660b7f1ecb5c41cdd95ad2f7105b9cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca956470c845c976ac25d43870d0da"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:aadca956470c845c976ac25d43870d0da"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; FixMathPrivate::FM_max(NI-op, 0), NF+op, FixMathPrivate::rangeShift(NI, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#aadca956470c845c976ac25d43870d0da">sR</a> ()</td></tr>
<tr class="separator:aadca956470c845c976ac25d43870d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff21f36dcf756d3ae806b38af577066c"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:aff21f36dcf756d3ae806b38af577066c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI+op, FixMathPrivate::FM_max(NF-op, 0), FixMathPrivate::rangeShift(NF, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#aff21f36dcf756d3ae806b38af577066c">sL</a> ()</td></tr>
<tr class="separator:aff21f36dcf756d3ae806b38af577066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2713361a7c85c7c5fb1479a85fa767f5"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a2713361a7c85c7c5fb1479a85fa767f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a2713361a7c85c7c5fb1479a85fa767f5">operator&gt;</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a2713361a7c85c7c5fb1479a85fa767f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3919f181cdf1a9789b0a4ddc3c7350df"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a3919f181cdf1a9789b0a4ddc3c7350df"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a3919f181cdf1a9789b0a4ddc3c7350df">operator&lt;</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a3919f181cdf1a9789b0a4ddc3c7350df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8ca8954a76ec1569dc1ed968e57c8"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:adbf8ca8954a76ec1569dc1ed968e57c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#adbf8ca8954a76ec1569dc1ed968e57c8">operator==</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:adbf8ca8954a76ec1569dc1ed968e57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e6b735d20ac94a07bd6ae1b6bc0c0c"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a22e6b735d20ac94a07bd6ae1b6bc0c0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a22e6b735d20ac94a07bd6ae1b6bc0c0c">operator!=</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a22e6b735d20ac94a07bd6ae1b6bc0c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae56f253ada7f3b73756616eac13e91"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a0ae56f253ada7f3b73756616eac13e91">asUFix</a> () const</td></tr>
<tr class="separator:a0ae56f253ada7f3b73756616eac13e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd75c2f6a196e16854ca189e8769624"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a3bd75c2f6a196e16854ca189e8769624">asFloat</a> () const</td></tr>
<tr class="separator:a3bd75c2f6a196e16854ca189e8769624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471ac4241e86f15f263db7c65478b20"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structIntegerType.html">IntegerType</a>&lt; FixMathPrivate::sBitsToBytes(NI+1)&gt;::signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a7471ac4241e86f15f263db7c65478b20">asInt</a> () const</td></tr>
<tr class="separator:a7471ac4241e86f15f263db7c65478b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30667c56d94bf030fbe51d4ed9950b08"><td class="memItemLeft" align="right" valign="top">constexpr internal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a30667c56d94bf030fbe51d4ed9950b08">asRaw</a> () const</td></tr>
<tr class="separator:a30667c56d94bf030fbe51d4ed9950b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0108a2ff808131b2bbcecee4d0c9b618"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0108a2ff808131b2bbcecee4d0c9b618"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a0108a2ff808131b2bbcecee4d0c9b618">fromRaw</a> (T raw)</td></tr>
<tr class="separator:a0108a2ff808131b2bbcecee4d0c9b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e26f89e3aa2969906d9ff3deaa53328"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a8e26f89e3aa2969906d9ff3deaa53328">getNI</a> ()</td></tr>
<tr class="separator:a8e26f89e3aa2969906d9ff3deaa53328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319ae49f75636efec3999140a31fc85c"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a319ae49f75636efec3999140a31fc85c">getNF</a> ()</td></tr>
<tr class="separator:a319ae49f75636efec3999140a31fc85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89df92655a3e9760b2954582043aaea7"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html#a89df92655a3e9760b2954582043aaea7">getRANGE</a> ()</td></tr>
<tr class="separator:a89df92655a3e9760b2954582043aaea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd681b9d4bfaa3141d9d96e05728a2"><td class="memTemplParams" colspan="2">template&lt;int8_t BITS&gt; </td></tr>
<tr class="memitem:a59bd681b9d4bfaa3141d9d96e05728a2"><td class="memTemplItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSFix.html#a59bd681b9d4bfaa3141d9d96e05728a2">assertSize</a> ()</td></tr>
<tr class="separator:a59bd681b9d4bfaa3141d9d96e05728a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab22bda4659913a0db678857c9aef1abe"><td class="memTemplParams" colspan="2"><a id="ab22bda4659913a0db678857c9aef1abe"></a>
template&lt;int8_t , int8_t , uint64_t &gt; </td></tr>
<tr class="memitem:ab22bda4659913a0db678857c9aef1abe"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UFix</b></td></tr>
<tr class="separator:ab22bda4659913a0db678857c9aef1abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt;<br />
class SFix&lt; NI, NF, RANGE &gt;</h3>

<p>Instanciate an signed fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NI</td><td>The number of bits encoding the integer part. The integral part can range into [-2^NI, 2^NI -1] </td></tr>
    <tr><td class="paramname">NF</td><td>The number of bits encoding the fractional part </td></tr>
    <tr><td class="paramname">RANGE</td><td>A purely internal parameter that keeps track of the range used by the type. Safer to <em>not</em> define it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The total number of the underlying int will be NI+NF+1 in order to accomodate the sign. It follows that, if you want something that reproduces the behavior of a int8_t, it should be declared as SFix&lt;7,0&gt;. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c98bb108b044af13a6329142c7b2de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c98bb108b044af13a6329142c7b2de6">&#9670;&nbsp;</a></span>SFix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a29b24255334b013518c060354dad8128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b24255334b013518c060354dad8128">&#9670;&nbsp;</a></span>SFix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An signed fixed point number </dd></dl>

</div>
</div>
<a id="af205019d40489f55d3be4ae1ffe603c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af205019d40489f55d3be4ae1ffe603c5">&#9670;&nbsp;</a></span>SFix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An signed fixed point number </dd></dl>

</div>
</div>
<a id="ae677662a0546de5535c93121e7bc1762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae677662a0546de5535c93121e7bc1762">&#9670;&nbsp;</a></span>SFix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as_raw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from an integer value which can be interpreted as both a resulting fixed point math number with a fractional part equals to 0, or as a number with decimal, ie as the underlying type behind the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer value </td></tr>
    <tr><td class="paramname">as_raw=false</td><td>with false value will be interpreted as an integer, with true it will be interpreted as a number with decimals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An signed fixed point number </dd></dl>

</div>
</div>
<a id="a2e1a7033339c03de9ceab22962740ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a7033339c03de9ceab22962740ed9">&#9670;&nbsp;</a></span>SFix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from another <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>A signed fixed type number which value can be represented in this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed fixed type number </dd></dl>

</div>
</div>
<a id="a164116927fa8b7664a7a4423efc50e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164116927fa8b7664a7a4423efc50e96">&#9670;&nbsp;</a></span>SFix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classSFix.html">SFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from an <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>A unsigned fixed type number which value can be represented in this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed fixed type number </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bd75c2f6a196e16854ca189e8769624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd75c2f6a196e16854ca189e8769624">&#9670;&nbsp;</a></span>asFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::asFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value as floating point number. </p><dl class="section return"><dt>Returns</dt><dd>The floating point value. </dd></dl>

</div>
</div>
<a id="a7471ac4241e86f15f263db7c65478b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7471ac4241e86f15f263db7c65478b20">&#9670;&nbsp;</a></span>asInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structIntegerType.html">IntegerType</a>&lt;FixMathPrivate::sBitsToBytes(NI+1)&gt;::signed_type <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::asInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the integer part of the number, as a standard C type integer (int8_t, int16_t etc) depending on NI. </p><dl class="section note"><dt>Note</dt><dd>Because numbers are stored as two's complement, this returns the closest integer <em>towards</em> negative values </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer part, as a C integer type. </dd></dl>

</div>
</div>
<a id="a30667c56d94bf030fbe51d4ed9950b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30667c56d94bf030fbe51d4ed9950b08">&#9670;&nbsp;</a></span>asRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal_type <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::asRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the internal integer value </p><dl class="section return"><dt>Returns</dt><dd>the internal value </dd></dl>

</div>
</div>
<a id="a59bd681b9d4bfaa3141d9d96e05728a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd681b9d4bfaa3141d9d96e05728a2">&#9670;&nbsp;</a></span>assertSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::assertSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check wether this number exceeds the given total size in bits. See <a class="el" href="classUFix.html#a4cce7ec1619e8b6d158e69ad437168c3">UFix::assertSize()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function counts the number of bits needed, internally, and including the sign bit. E.g. SFix&lt;8,0&gt;::assertSize&lt;8&gt;() will fail, as it requires 9 bits, internally! </dd></dl>

</div>
</div>
<a id="a0ae56f253ada7f3b73756616eac13e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae56f253ada7f3b73756616eac13e91">&#9670;&nbsp;</a></span>asUFix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NI,NF,RANGE&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::asUFix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number as a <a class="el" href="classUFix.html">UFix</a> of same (positive) range and precision. The initial value has to be positive to return something correct. This is more optimized than a cast. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classUFix.html">UFix</a> </dd></dl>

</div>
</div>
<a id="a0108a2ff808131b2bbcecee4d0c9b618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108a2ff808131b2bbcecee4d0c9b618">&#9670;&nbsp;</a></span>fromRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::fromRaw </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the internal value of the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The new internal value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a319ae49f75636efec3999140a31fc85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319ae49f75636efec3999140a31fc85c">&#9670;&nbsp;</a></span>getNF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::getNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the fractional part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the fractional part. </dd></dl>

</div>
</div>
<a id="a8e26f89e3aa2969906d9ff3deaa53328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e26f89e3aa2969906d9ff3deaa53328">&#9670;&nbsp;</a></span>getNI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::getNI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the integral part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the integral part. </dd></dl>

</div>
</div>
<a id="a89df92655a3e9760b2954582043aaea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89df92655a3e9760b2954582043aaea7">&#9670;&nbsp;</a></span>getRANGE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::getRANGE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (absolute) range of the integral part of the number, as far as it can be determined at compile time. The true range of the number will typically be lower than (at most the same as) this, so it is not recommended to use this in computations. Available with #define FIXMATH_DEBUG </p><dl class="section return"><dt>Returns</dt><dd>The range of the number </dd></dl>

</div>
</div>
<a id="a9a77192383382e2ba7496c614db81343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a77192383382e2ba7496c614db81343">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NF,_NF&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a SFix&lt;NI,NF&gt;, as a SFix&lt;NF,_NF&gt;. _NF is the number of precision bits for the output. Can be any number but especially useful for case between <a class="el" href="classSFix.html#ac02cc3a7746ce0550428095d8cba9eba">invFast()</a> (_NF=NI) and <a class="el" href="classSFix.html#a35ca66653e6de4958b0ccb22b644f66e">invFull()</a> (_NF=2*NI+NF) </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a7937916cb7c7aae5fbb33165df113445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7937916cb7c7aae5fbb33165df113445">&#9670;&nbsp;</a></span>invAccurate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NF = FixMathPrivate::FM_min(NI*2+NF-1,63-NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NF,_NF&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::invAccurate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a SFix&lt;NI,NF&gt;, as a <a class="el" href="classSFix.html">SFix</a>&lt;NF,NI*2+NF-1&gt; (default) or as a SFix&lt;NF,_NF&gt; with _NF the template parameter of invAccurate&lt;_NF&gt;. </p><dl class="section note"><dt>Note</dt><dd>This uses a number of width NF+_NF+1 internally. If you are seeking for performances, you should try to aim for this number to not require a too big a type internally. For instance SFix&lt;0,15&gt; a; a.invAccurate&lt;16&gt;() will use a 64 bits internally whereas a.invAccurate&lt;15&gt;() will only use a 32 bits. It can be called as a.invAccurate() (default) or a.invAccurate&lt;16&gt; for instance. </dd></dl>

</div>
</div>
<a id="ac02cc3a7746ce0550428095d8cba9eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02cc3a7746ce0550428095d8cba9eba">&#9670;&nbsp;</a></span>invFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NF,NI&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::invFast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a SFix&lt;NI,NF&gt;, as a SFix&lt;NF,NI&gt; (not a typo). This inverse is able to represent accurately the inverse of the smallest and biggest of the initial number, but might lead to a lot of duplicates in between. Good if precision is not a premium but type conservation and speeds are. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a35ca66653e6de4958b0ccb22b644f66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ca66653e6de4958b0ccb22b644f66e">&#9670;&nbsp;</a></span>invFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NF,FixMathPrivate::FM_min(NI*2+NF,63-NF)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::invFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a SFix&lt;NI,NF&gt;, as a <a class="el" href="classSFix.html">SFix</a>&lt;NF,NI*2+NF&gt;. This inverse is more accurate than invFast, and usually leads to non common values on the whole input range. This comes at the cost of a way bigger resulting type. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a22e6b735d20ac94a07bd6ae1b6bc0c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e6b735d20ac94a07bd6ae1b6bc0c0c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is not equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="a25b81f170bb1348644459843c23dc0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b81f170bb1348644459843c23dc0c6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication with another <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a0378525fe44b041e160eb32038bf30bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0378525fe44b041e160eb32038bf30bf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication between a <a class="el" href="classSFix.html">SFix</a> and a <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication of op1 and op2. As a <a class="el" href="classSFix.html">SFix</a> </dd></dl>

</div>
</div>
<a id="a6897e22fd904f54fdb7555b7bee852f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6897e22fd904f54fdb7555b7bee852f6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with another <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="ac991db0bee7ebb63e091582d41e9c766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac991db0bee7ebb63e091582d41e9c766">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition between a <a class="el" href="classSFix.html">SFix</a> and a <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition of op1 and op2. As a <a class="el" href="classSFix.html">SFix</a> </dd></dl>

</div>
</div>
<a id="ae72d489b35d6ec78315735a0a411b39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72d489b35d6ec78315735a0a411b39a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;NF,RANGE+1&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite of the number (unary minus operator). </p><dl class="section return"><dt>Returns</dt><dd>The opposite numberas a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a8eabdb5d47e38190bf7d25430c7a8256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eabdb5d47e38190bf7d25430c7a8256">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction with another <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="aecff8ee0cac43d3262f1453b03c17fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecff8ee0cac43d3262f1453b03c17fd5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction with a <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a3919f181cdf1a9789b0a4ddc3c7350df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3919f181cdf1a9789b0a4ddc3c7350df">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is smaller than op, false otherwise </dd></dl>

</div>
</div>
<a id="adbf8ca8954a76ec1569dc1ed968e57c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf8ca8954a76ec1569dc1ed968e57c8">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="a2713361a7c85c7c5fb1479a85fa767f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2713361a7c85c7c5fb1479a85fa767f5">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is bigger than op, false otherwise </dd></dl>

</div>
</div>
<a id="a660b7f1ecb5c41cdd95ad2f7105b9cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660b7f1ecb5c41cdd95ad2f7105b9cdf">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const int8_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right shift. This won't overflow but will not leverage on the bits freed by the shift. Better to use .<a class="el" href="classSFix.html#aadca956470c845c976ac25d43870d0da">sR&lt;shift&gt;()</a> if possible instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="aff21f36dcf756d3ae806b38af577066c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff21f36dcf756d3ae806b38af577066c">&#9670;&nbsp;</a></span>sL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NI+op,FixMathPrivate::FM_max(NF-op,0),FixMathPrivate::rangeShift(NF,op,RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::sL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal left shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of bigger size. </dd></dl>

</div>
</div>
<a id="aadca956470c845c976ac25d43870d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadca956470c845c976ac25d43870d0da">&#9670;&nbsp;</a></span>sR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;FixMathPrivate::FM_max(NI-op,0), NF+op, FixMathPrivate::rangeShift(NI,op,RANGE)&gt; <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;::sR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal right shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of smaller size. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FixMath_8h_source.html">FixMath.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
