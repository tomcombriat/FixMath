<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FixMath: FixMath.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FixMath
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FixMath.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;Arduino.h&gt;</code><br />
<code>#include &quot;IntegerType.h&quot;</code><br />
<code>#include &quot;FixMath_Autotests.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for FixMath.h:</div>
<div class="dyncontent">
<div class="center"><img src="FixMath_8h__incl.png" border="0" usemap="#aFixMath_8h" alt=""/></div>
<map name="aFixMath_8h" id="aFixMath_8h">
<area shape="rect" title=" " alt="" coords="51,5,137,32"/>
<area shape="rect" title=" " alt="" coords="5,155,89,181"/>
<area shape="rect" href="IntegerType_8h_source.html" title=" " alt="" coords="39,80,149,107"/>
<area shape="rect" href="FixMath__Autotests_8h_source.html" title=" " alt="" coords="174,80,329,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="FixMath_8h__dep__incl.png" border="0" usemap="#aFixMath_8hdep" alt=""/></div>
<map name="aFixMath_8hdep" id="aFixMath_8hdep">
<area shape="rect" title=" " alt="" coords="30,5,115,32"/>
<area shape="rect" href="FixMathMapper_8h_source.html" title=" " alt="" coords="5,80,140,107"/>
</map>
</div>
</div>
<p><a href="FixMath_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFixMathPrivate_1_1BitCounter.html">FixMathPrivate::BitCounter&lt; value, bits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFixMathPrivate_1_1BitCounter_3_01value_00_010_01_4.html">FixMathPrivate::BitCounter&lt; value, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html">UFix&lt; NI, NF, RANGE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSFix.html">SFix&lt; NI, NF, RANGE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFixMathPrivate"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFixMathPrivate.html">FixMathPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aee77e7ee48eea928f764de45506efe67"><td class="memTemplParams" colspan="2"><a id="aee77e7ee48eea928f764de45506efe67"></a>
template&lt;int8_t NF, uint64_t RANGE&gt; </td></tr>
<tr class="memitem:aee77e7ee48eea928f764de45506efe67"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::UFixByRange_t</b> = <a class="el" href="classUFix.html">UFix</a>&lt; NIcount&lt; RANGE &gt;() -NF, NF, RANGE &gt;</td></tr>
<tr class="separator:aee77e7ee48eea928f764de45506efe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f17b62eb0b42c7169d4fbd4230dd756"><td class="memTemplParams" colspan="2"><a id="a4f17b62eb0b42c7169d4fbd4230dd756"></a>
template&lt;int8_t NF, uint64_t RANGE&gt; </td></tr>
<tr class="memitem:a4f17b62eb0b42c7169d4fbd4230dd756"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::SFixByRange_t</b> = <a class="el" href="classSFix.html">SFix</a>&lt; NIcount&lt; RANGE-1 &gt;() -NF, NF, RANGE &gt;</td></tr>
<tr class="separator:a4f17b62eb0b42c7169d4fbd4230dd756"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c50c54147c6ea1244d6ea6ad704c89c"><td class="memTemplParams" colspan="2"><a id="a4c50c54147c6ea1244d6ea6ad704c89c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c50c54147c6ea1244d6ea6ad704c89c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::shiftR</b> (T x, int8_t bits)</td></tr>
<tr class="separator:a4c50c54147c6ea1244d6ea6ad704c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e10b7b541c7ae909307e2ca85a13d61"><td class="memItemLeft" align="right" valign="top"><a id="a1e10b7b541c7ae909307e2ca85a13d61"></a>
constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::sBitsToBytes</b> (int8_t N)</td></tr>
<tr class="separator:a1e10b7b541c7ae909307e2ca85a13d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b39694991fa2271411af05f726266"><td class="memItemLeft" align="right" valign="top"><a id="a9a4b39694991fa2271411af05f726266"></a>
constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::uBitsToBytes</b> (int8_t N)</td></tr>
<tr class="separator:a9a4b39694991fa2271411af05f726266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8bcab7935ec3c6cfabc62507cda1ae"><td class="memTemplParams" colspan="2"><a id="aee8bcab7935ec3c6cfabc62507cda1ae"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee8bcab7935ec3c6cfabc62507cda1ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::FM_max</b> (T N1, T N2)</td></tr>
<tr class="separator:aee8bcab7935ec3c6cfabc62507cda1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ee7285a1ca23cb62506d2d62a02c1a"><td class="memTemplParams" colspan="2"><a id="ac7ee7285a1ca23cb62506d2d62a02c1a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7ee7285a1ca23cb62506d2d62a02c1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::FM_min</b> (T N1, T N2)</td></tr>
<tr class="separator:ac7ee7285a1ca23cb62506d2d62a02c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e68970fe1292706c8111c4633bf05e4"><td class="memItemLeft" align="right" valign="top"><a id="a0e68970fe1292706c8111c4633bf05e4"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::sFullRange</b> (int8_t N)</td></tr>
<tr class="separator:a0e68970fe1292706c8111c4633bf05e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e58aeec4388303d6e0a529e43f20965"><td class="memItemLeft" align="right" valign="top"><a id="a2e58aeec4388303d6e0a529e43f20965"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::uFullRange</b> (int8_t N)</td></tr>
<tr class="separator:a2e58aeec4388303d6e0a529e43f20965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caf353bbd3661d13479e08aaf63045d"><td class="memItemLeft" align="right" valign="top"><a id="a8caf353bbd3661d13479e08aaf63045d"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::rangeAdd</b> (byte NF, byte _NF, uint64_t RANGE, uint64_t _RANGE)</td></tr>
<tr class="separator:a8caf353bbd3661d13479e08aaf63045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96afba7d43238189112a0d0a72c0675a"><td class="memItemLeft" align="right" valign="top"><a id="a96afba7d43238189112a0d0a72c0675a"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>FixMathPrivate::rangeShift</b> (int8_t N, int8_t SH, uint64_t RANGE)</td></tr>
<tr class="separator:a96afba7d43238189112a0d0a72c0675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d991a08b2698d42ecf1605918270b8"><td class="memTemplParams" colspan="2"><a id="a20d991a08b2698d42ecf1605918270b8"></a>
template&lt;uint64_t value&gt; </td></tr>
<tr class="memitem:a20d991a08b2698d42ecf1605918270b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr int8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FixMathPrivate::NIcount</b> ()</td></tr>
<tr class="separator:a20d991a08b2698d42ecf1605918270b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c690d265da5284fa40b19574b286cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6c690d265da5284fa40b19574b286cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; 0, sizeof(T) *8 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#ab6c690d265da5284fa40b19574b286cb">toUFraction</a> (T val)</td></tr>
<tr class="separator:ab6c690d265da5284fa40b19574b286cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda76ba96e4ae059e3872b080b6c681"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dda76ba96e4ae059e3872b080b6c681"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; sizeof(T) *8, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a0dda76ba96e4ae059e3872b080b6c681">toUInt</a> (T val)</td></tr>
<tr class="separator:a0dda76ba96e4ae059e3872b080b6c681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217a77f6a6d862840d6f610a92c9f65"><td class="memTemplParams" colspan="2">template&lt;uint64_t value&gt; </td></tr>
<tr class="memitem:a0217a77f6a6d862840d6f610a92c9f65"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt; 0, value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a0217a77f6a6d862840d6f610a92c9f65">UFixAuto</a> ()</td></tr>
<tr class="separator:a0217a77f6a6d862840d6f610a92c9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ff3e79510e17f13056c58a2191be18"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a85ff3e79510e17f13056c58a2191be18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a85ff3e79510e17f13056c58a2191be18">operator&gt;</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:a85ff3e79510e17f13056c58a2191be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e19acc8c3adaa3296148c1e6ebdde"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a771e19acc8c3adaa3296148c1e6ebdde"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a771e19acc8c3adaa3296148c1e6ebdde">operator&gt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:a771e19acc8c3adaa3296148c1e6ebdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70883fc4f0dc62c55a831a506602d96"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:ad70883fc4f0dc62c55a831a506602d96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#ad70883fc4f0dc62c55a831a506602d96">operator&lt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:ad70883fc4f0dc62c55a831a506602d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773f1f3dca60ecd08756268c4e1581d"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:ab773f1f3dca60ecd08756268c4e1581d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#ab773f1f3dca60ecd08756268c4e1581d">operator&lt;</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:ab773f1f3dca60ecd08756268c4e1581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8bf5f8934ac98afb345f29feefb712"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a8b8bf5f8934ac98afb345f29feefb712"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a8b8bf5f8934ac98afb345f29feefb712">operator==</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:a8b8bf5f8934ac98afb345f29feefb712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5352a505056ab3e61f3364a6f43f33bf"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a5352a505056ab3e61f3364a6f43f33bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a5352a505056ab3e61f3364a6f43f33bf">operator==</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:a5352a505056ab3e61f3364a6f43f33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa4c56f004c4bcf800359a3907a42ef"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a0fa4c56f004c4bcf800359a3907a42ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#a0fa4c56f004c4bcf800359a3907a42ef">operator!=</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:a0fa4c56f004c4bcf800359a3907a42ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4dc21682154845652c89a69a48ca18"><td class="memTemplParams" colspan="2">template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:aae4dc21682154845652c89a69a48ca18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#aae4dc21682154845652c89a69a48ca18">operator!=</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;op1, const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;op2)</td></tr>
<tr class="separator:aae4dc21682154845652c89a69a48ca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7fece5e8162407f033d0fbf022ad15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac7fece5e8162407f033d0fbf022ad15"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; 0, sizeof(T) *8-1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#aac7fece5e8162407f033d0fbf022ad15">toSFraction</a> (T val)</td></tr>
<tr class="separator:aac7fece5e8162407f033d0fbf022ad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac479196160eb99ddf534e0768e3f1990"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac479196160eb99ddf534e0768e3f1990"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; sizeof(T) *8-1, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="FixMath_8h.html#ac479196160eb99ddf534e0768e3f1990">toSInt</a> (T val)</td></tr>
<tr class="separator:ac479196160eb99ddf534e0768e3f1990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements two fixed point number classes. These numbers can have a fractional part but are actually standard integers under the hood which makes calculations with them efficient on platforms which do not have a FPU like most micro-controllers. These numbers can be signed (<a class="el" href="classSFix.html">SFix</a>) or unsigned (<a class="el" href="classUFix.html">UFix</a>).</p>
<p>A fixed point number has its range defined by the number of bits encoding the integer part (NI in the following) and its precision by the number of bits encoding the fractional part (NF). For <a class="el" href="classUFix.html">UFix</a> types, the integral part can hold values in [0,2^NI-1], for <a class="el" href="classSFix.html">SFix</a> types, the integral part can hold values in [-2^NI,2^NI-1]. The number of bits encoding the fractional can be considered as the precision of the number: given NF, the number of possible values in the [0,1[ range will 2^NF. Hence, given NF, the resolution will be 1/(2^NF).</p>
<p>Under the hood, these types will keep track of the maximum possible value they might hold (this is the RANGE template parameter), and, if only <em>SAFE</em> operations (see below) are used, will automatically adjust there NI and NF to accomodate the result of a operation. It will also try not to promote there internal type when possible, assuFM_ming that you use the complete range of a given type.</p>
<p>The operations possible with these types can be divided into two categories:</p><ul>
<li>the operations between FixMath types are all safe (aka won't overflow) and are the only one included by default</li>
<li>the operations between a FixMath and a native C type (int, float) are NOT safe and are not included by default. In order to activate them, you need to <code>#define FIXMATH_UNSAFE</code> before including <a class="el" href="FixMath_8h.html">FixMath.h</a>.</li>
</ul>
<p>Like standard C(++) types, the fixed point numbers defined here are following some rules:</p><ul>
<li>any fixed type can be converted to another <em>as long as the value can be represented in the destination type</em>. Casting to a bigger type in term of NI and NF is safe, but reducing NI can lead to an overflow if the new type cannot hold the integer value and reducing NF leads to a loss of precision.</li>
<li>Fixed types can be constructed from and converted to standard C types:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;(T value)</code> will convert the <code>value</code> to a <code><a class="el" href="classUFix.html">UFix</a></code>. If T is an integer type the final number will have a fractional part equal to zero. This can be used as a standard type, for example: <code><a class="el" href="classUFix.html">UFix</a>&lt;8,8&gt; a = 15;</code> or <code><a class="el" href="classUFix.html">UFix</a>&lt;8,8&gt; b = 200.25;</code></li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;::fromRaw(T value)</code> will set the <em>internal</em> value of the <code><a class="el" href="classUFix.html">UFix</a></code>. For example <code><a class="el" href="classUFix.html">UFix</a>&lt;7,1&gt;::fromRaw(16);</code> is actually 8</li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.toFloat()</code> returns the value as a <code>float</code></li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.asRaw()</code> returns the internal value</li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
</ul>
</li>
<li>all operations between fixed point number is safe (it won't overflow) and preserve the precision. In particular:<ul>
<li>only addition, subtraction and multiplication are implemented (this is a design choice, see below)</li>
<li>any operation between a signed and an unsigned leads to a signed number</li>
<li>resulting numbers will be casted to a type big enough to store the expected values. It follows that it is worth starting with types that are as small as possible to hold the initial value.</li>
<li>all operations between a fixed point number and a native type (int, float, uint) are <em>not</em> safe. If the resulting value cannot be represented in the fixed point type it will overflow. Only addition, subtraction, multiplication and right/left shift are implemented. These are only accessible activating the <code>FIXMATH_UNSAFE</code> set.</li>
<li>safe right/left shifts, which return the correct value in the correct type are implemented as .sR&lt;shift&gt;() and .sL&lt;shift&gt;() respectively, shift being the shifting amount.</li>
</ul>
</li>
</ul>
<p>More specifically on the returned types of the operations between fixed point math types:</p><ul>
<li>Additions:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; + <a class="el" href="classUFix.html">UFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;MAX(NI,_NI)+1,MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; + <a class="el" href="classSFix.html">SFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;MAX(NI,_NI)+1,MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; + <a class="el" href="classSFix.html">SFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;MAX(NI,_NI)+1,MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; + anything_else</code> (signed or not) returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; + anything_else</code> (signed or not) returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
</ul>
</li>
<li>Subtractions:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; - <a class="el" href="classUFix.html">UFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;MAX(NI,_NI),MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; - <a class="el" href="classSFix.html">SFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;MAX(NI,_NI)+1,MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; - <a class="el" href="classUFix.html">UFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;MAX(NI,_NI)+1,MAX(NF,_NF)&gt;</code> at worse</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; - anything_else</code> (signed or not) returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; - anything_else</code> (signed or not) returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li><code>(-)<a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code> return <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code></li>
<li><code>(-)<a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> return <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code></li>
</ul>
</li>
<li>Multiplications:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; * <a class="el" href="classUFix.html">UFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI+_NI,NF+_NF&gt;</code> at worse</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; * <a class="el" href="classSFix.html">SFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI+_NI,NF+_NF&gt;</code> at worse</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; * <a class="el" href="classSFix.html">SFix</a>&lt;_NI,_NF&gt;</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI+_NI,NF+_NF&gt;</code> at worse</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; * anything_else</code> (signed or not) returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt; * anything_else</code> (signed or not) returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
</ul>
</li>
<li>Shifts:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; .sR&lt;NS&gt;</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI-NS,NF+NS&gt;</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; .sL&lt;NS&gt;</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI+NS,NF-NS&gt;</code></li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; &gt;&gt; N</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; &lt;&lt; N</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code> (only available with <code>FIXMATH_UNSAFE</code>)</li>
<li>same for <code><a class="el" href="classSFix.html">SFix</a></code></li>
</ul>
</li>
<li>Inverse:<ul>
<li>Approximates:<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.invFast()</code> returns the approximate inverse of the number as <code><a class="el" href="classUFix.html">UFix</a>&lt;NF,NI&gt;</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.invFast()</code> returns the approximate inverse of the number as <code><a class="el" href="classSFix.html">SFix</a>&lt;NF,NI&gt;</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.invFull()</code> returns the approximate inverse of the number as <code><a class="el" href="classUFix.html">UFix</a>&lt;NF,2*NI+NF&gt;</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.invFull()</code> returns the approximate inverse of the number as <code><a class="el" href="classSFix.html">SFix</a>&lt;NF,2*NI+NF&gt;</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.inv&lt;_NF&gt;()</code> returns the approximate inverse of the number as <code><a class="el" href="classUFix.html">UFix</a>&lt;NF,_NF&gt;</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.inv&lt;_NF&gt;()</code> returns the approximate inverse of the number as <code><a class="el" href="classSFix.html">SFix</a>&lt;NF,_NF&gt;</code></li>
</ul>
</li>
<li>Exact: (when the result can be exactly represented in the destination type)<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.invAccurate()</code> returns the inverse as <code><a class="el" href="classUFix.html">UFix</a>&lt;NF,2*NI+NF-1&gt;</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.invAccurate()</code> returns the inverse as <code><a class="el" href="classSFix.html">SFix</a>&lt;NF,2*NI+NF-1&gt;</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.invAccurate&lt;_NF&gt;()</code> returns the inverse as <code><a class="el" href="classUFix.html">UFix</a>&lt;NF,_NF&gt;</code> (uses NF+_NF+1 bits internally)</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.invAccurate()&lt;_NF&gt;</code> returns the inverse as <code><a class="el" href="classSFix.html">SFix</a>&lt;NF,_NF&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>Conversion (should be preferred over casting, when possible):<ul>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.asSFix()</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.asUFix()</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.asFloat()</code> returns the value as a <code>float</code></li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.asFloat()</code> returns the value as a <code>float</code></li>
<li><code><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt;.asRaw()</code> returns the internal value</li>
<li><code><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF&gt;.asRaw()</code> returns the internal value</li>
<li><code>T.toUFraction()</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;0,NF&gt;</code> with <code>NF</code> the number of bits of <code>T</code> (<code>uint8_t</code> leads to <code>NF=8</code>bits).</li>
<li><code>T.toSFraction()</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;0,NF&gt;</code> with <code>NF</code> the number of bits of <code>T</code> (<code>int8_t</code> leads to <code>NF=7</code>bits).</li>
<li><code>T.toUInt()</code> returns <code><a class="el" href="classUFix.html">UFix</a>&lt;NI,0&gt;</code> with <code>NI</code> the number of bits of <code>T</code> (<code>uint8_t</code> leads to <code>NI=8</code>bits).</li>
<li><code>T.toSInt()</code> returns <code><a class="el" href="classSFix.html">SFix</a>&lt;NI,&gt;</code> with <code>NI</code> the number of bits of <code>T</code> (<code>int8_t</code> leads to <code>NI=7</code>bits). <br  />
</li>
</ul>
</li>
</ul>
<p>Note on division: The division is not implemented. This is a deliberate choice made for two reasons:</p><ul>
<li>in contrast with all the other fundamental operations, it is not possible to guarantee that precision will be kept (other operations returns <em>exact</em> results whenever the operands were also exactly represented. Note that this is actually not the case when using normal floating point numbers. The inverse functions can be used to fake a division, by multiplying by the inverse of a number.</li>
<li>division are usually very slow operations on MCU, hence there usage is discouraged. The ideal way of doing it is to compute the inverse whenever needed and only when needed. In the context of Mozzi for instance, a good way to do it would be to compute needed inverses in <code>updateControl()</code>, and use them in <code>updateAudio()</code>. </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0fa4c56f004c4bcf800359a3907a42ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa4c56f004c4bcf800359a3907a42ef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classSFix.html">SFix</a> and an <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is not equal to op2, false otherwise </dd></dl>

</div>
</div>
<a id="aae4dc21682154845652c89a69a48ca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4dc21682154845652c89a69a48ca18">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classUFix.html">UFix</a> and an <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classUFix.html">UFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is not equal to op2, false otherwise </dd></dl>

</div>
</div>
<a id="ab773f1f3dca60ecd08756268c4e1581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab773f1f3dca60ecd08756268c4e1581d">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classSFix.html">SFix</a> and an <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is smaller than op2, false otherwise </dd></dl>

</div>
</div>
<a id="ad70883fc4f0dc62c55a831a506602d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70883fc4f0dc62c55a831a506602d96">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classUFix.html">UFix</a> and an <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classUFix.html">UFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is smaller than op2, false otherwise </dd></dl>

</div>
</div>
<a id="a8b8bf5f8934ac98afb345f29feefb712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8bf5f8934ac98afb345f29feefb712">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classSFix.html">SFix</a> and an <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is equal to op2, false otherwise </dd></dl>

</div>
</div>
<a id="a5352a505056ab3e61f3364a6f43f33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5352a505056ab3e61f3364a6f43f33bf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classUFix.html">UFix</a> and an <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classUFix.html">UFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is equal to op2, false otherwise </dd></dl>

</div>
</div>
<a id="a85ff3e79510e17f13056c58a2191be18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ff3e79510e17f13056c58a2191be18">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classSFix.html">SFix</a> and an <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classSFix.html">SFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is bigger than op2, false otherwise </dd></dl>

</div>
</div>
<a id="a771e19acc8c3adaa3296148c1e6ebdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771e19acc8c3adaa3296148c1e6ebdde">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison between a <a class="el" href="classUFix.html">UFix</a> and an <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>a <a class="el" href="classUFix.html">UFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if op1 is bigger than op2, false otherwise </dd></dl>

</div>
</div>
<a id="aac7fece5e8162407f033d0fbf022ad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7fece5e8162407f033d0fbf022ad15">&#9670;&nbsp;</a></span>toSFraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;0, sizeof(T)*8-1&gt; toSFraction </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <em>pure</em> fractional signed fixed number (<a class="el" href="classSFix.html">SFix</a>) from an integer. The number of fractional bits (NF) is chosen automatically depending on the input type. Hence toSFraction(127) and toSFraction(int8_t(127)) <em>do not</em> lead to the same thing: on an AVR, the former will lead to NF=15 - which is overkill and incorrect if you expect toSFraction(127) = 1 - whereas the latter will lead to NF=7. Mozzi's objects (Oscil and the like) returns correct types, hence you can use this function to convert the return value of a Mozzi's function/class member into a pure fractional number.</p>
<dl class="section note"><dt>Note</dt><dd>If the value is known at compile time, it is much more efficient to construct using SFixAuto(), and then shifting to the right.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to be converted into a pure fractional number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SFix&lt;0,NF&gt; with NF chosen according to the input type </dd></dl>

</div>
</div>
<a id="ac479196160eb99ddf534e0768e3f1990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac479196160eb99ddf534e0768e3f1990">&#9670;&nbsp;</a></span>toSInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;sizeof(T)*8-1,0&gt; toSInt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <em>pure</em> integer signed fixed number (<a class="el" href="classSFix.html">SFix</a>) from an integer. The number of fractional bits (NI) is chosen automatically depending on the input type. Hence toSInt(127) and toSInt(int8_t(127)) <em>do not</em> lead to the same thing: on an AVR, the former will lead to NI=15 - which is overkill - whereas the latter will lead to NI=7. Mozzi's objects (Oscil and the like) returns correct types, hence you can use this function to convert the return value of a Mozzi's function/class member into a pure fractional number.</p>
<dl class="section note"><dt>Note</dt><dd>If the value is known at compile time, it is much more efficient to construct using SFixAuto().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to be converted into a pure integer fixed math number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SFix&lt;NI,0&gt; with NI chosen according to the input type </dd></dl>

</div>
</div>
<a id="ab6c690d265da5284fa40b19574b286cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c690d265da5284fa40b19574b286cb">&#9670;&nbsp;</a></span>toUFraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;0, sizeof(T)*8&gt; toUFraction </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <em>pure</em> fractional unsigned fixed number (<a class="el" href="classUFix.html">UFix</a>) from an unsigned integer. The number of fractional bits (NF) is chosen automatically depending on the input type. Hence toUFraction(255) and toUFraction(uint8_t(255)) <em>do not</em> lead to the same thing: on an AVR, the former will lead to NF=16 - which is overkill and incorrect if you expect toUFraction(255) = 1 - whereas the latter will lead to NF=8. Mozzi's objects (Oscil and the like) returns correct types, hence you can use this function to convert the return value of a Mozzi's function/class member into a pure fractional number.</p>
<dl class="section note"><dt>Note</dt><dd>If the value is known at compile time, it is much more efficient to construct using <a class="el" href="FixMath_8h.html#a0217a77f6a6d862840d6f610a92c9f65">UFixAuto()</a>, and then shifting to the right.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to be converted into a pure fractional number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UFix&lt;0,NF&gt; with NF chosen according to the input type </dd></dl>

</div>
</div>
<a id="a0dda76ba96e4ae059e3872b080b6c681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dda76ba96e4ae059e3872b080b6c681">&#9670;&nbsp;</a></span>toUInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;sizeof(T)*8,0&gt; toUInt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <em>pure</em> integer unsigned fixed number (<a class="el" href="classUFix.html">UFix</a>) from an unsigned integer. The number of fractional bits (NI) is chosen automatically depending on the input type. Hence toUInt(255) and toUInt(uint8_t(255)) <em>do not</em> lead to the same thing: on an AVR, the former will lead to NI=16 - which is overkill - whereas the latter will lead to NI=8. Mozzi's objects (Oscil and the like) returns correct types, hence you can use this function to convert the return value of a Mozzi's function/class member into a pure fractional number.</p>
<dl class="section note"><dt>Note</dt><dd>If the value is known at compile time, it is much more efficient to construct using <a class="el" href="FixMath_8h.html#a0217a77f6a6d862840d6f610a92c9f65">UFixAuto()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to be converted into a pure unsigned integer fixed math number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UFix&lt;NI,0&gt; with NI chosen according to the input type </dd></dl>

</div>
</div>
<a id="a0217a77f6a6d862840d6f610a92c9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0217a77f6a6d862840d6f610a92c9f65">&#9670;&nbsp;</a></span>UFixAuto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint64_t value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt;0, value&gt; UFixAuto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a pure integer unsigned fix number (<a class="el" href="classUFix.html">UFix</a>) from a compile time constant. The number of integer bits needed is determined, automatically, based on the actual value. This allows to easily create constants requiring minimal storage, without counting bits, manually.</p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> three = UFixAuto&lt;3&gt;();                     <span class="comment">// UFix&lt;2, 0&gt;</span></div>
<div class="line"><span class="keyword">auto</span> ten_point_five = UFixAuto&lt;21&gt;().sR&lt;1&gt;();   <span class="comment">// UFix&lt;5, 1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> nearly_Pi = UFixAuto&lt;201&gt;().sR&lt;6&gt;();       <span class="comment">// UFix&lt;2, 6&gt; = 3.140625</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
