<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FixMath: UFix&lt; NI, NF, RANGE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FixMath
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classUFix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UFix&lt; NI, NF, RANGE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="FixMath_8h_source.html">FixMath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d909dea6bd0d94f1e159450f46df265"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a7d909dea6bd0d94f1e159450f46df265">UFix</a> ()</td></tr>
<tr class="separator:a7d909dea6bd0d94f1e159450f46df265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432caf716e07f7d69e8f06b49b0dc477"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a432caf716e07f7d69e8f06b49b0dc477">UFix</a> (float fl)</td></tr>
<tr class="separator:a432caf716e07f7d69e8f06b49b0dc477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58949c734f134faf346be3f7379f4ed8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a58949c734f134faf346be3f7379f4ed8">UFix</a> (double fl)</td></tr>
<tr class="separator:a58949c734f134faf346be3f7379f4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7390119d769ae15f450a5d4fefb50d32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7390119d769ae15f450a5d4fefb50d32"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a7390119d769ae15f450a5d4fefb50d32">UFix</a> (T value, bool as_raw=false)</td></tr>
<tr class="separator:a7390119d769ae15f450a5d4fefb50d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17e095fb2fa03aa8f4d3e61643edcf4"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ae17e095fb2fa03aa8f4d3e61643edcf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae17e095fb2fa03aa8f4d3e61643edcf4">UFix</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;uf)</td></tr>
<tr class="separator:ae17e095fb2fa03aa8f4d3e61643edcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3838a6723b019a40df100732ec1bd9b"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:af3838a6723b019a40df100732ec1bd9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#af3838a6723b019a40df100732ec1bd9b">UFix</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;uf)</td></tr>
<tr class="separator:af3838a6723b019a40df100732ec1bd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae855ab54e2b28c755c41ad0941fbe33a"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ae855ab54e2b28c755c41ad0941fbe33a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae855ab54e2b28c755c41ad0941fbe33a">operator+</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:ae855ab54e2b28c755c41ad0941fbe33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc26f823f4151d244bce276d8e39c985"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:acc26f823f4151d244bce276d8e39c985"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#acc26f823f4151d244bce276d8e39c985">operator+</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:acc26f823f4151d244bce276d8e39c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59470679dbbaa691a12b09554195fd45"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a59470679dbbaa691a12b09554195fd45"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::FM_max(FixMathPrivate::shiftR(RANGE, FixMathPrivate::FM_max(NF, _NF) -NF), FixMathPrivate::shiftR(_RANGE, FixMathPrivate::FM_max(NF, _NF) -_NF))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a59470679dbbaa691a12b09554195fd45">operator-</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a59470679dbbaa691a12b09554195fd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe821e3f4919ee8407aac4ef4ae6cb1"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:aefe821e3f4919ee8407aac4ef4ae6cb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#aefe821e3f4919ee8407aac4ef4ae6cb1">operator-</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op2) const</td></tr>
<tr class="separator:aefe821e3f4919ee8407aac4ef4ae6cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20414eb474cfb24b9c0da72ce507d5fe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a20414eb474cfb24b9c0da72ce507d5fe">operator-</a> () const</td></tr>
<tr class="separator:a20414eb474cfb24b9c0da72ce507d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d297515c30a6e4f2895a3c73e8aa2f"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ac6d297515c30a6e4f2895a3c73e8aa2f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt; NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ac6d297515c30a6e4f2895a3c73e8aa2f">operator*</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:ac6d297515c30a6e4f2895a3c73e8aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08634f2ec6f686e781e0805aa8c8c69"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ae08634f2ec6f686e781e0805aa8c8c69"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt; NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae08634f2ec6f686e781e0805aa8c8c69">operator*</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:ae08634f2ec6f686e781e0805aa8c8c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa958c40d69f0926ea9d0ee187ed16006"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NF, NI &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#aa958c40d69f0926ea9d0ee187ed16006">invFast</a> () const</td></tr>
<tr class="separator:aa958c40d69f0926ea9d0ee187ed16006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa277fb8de13ef075c2f01048b0b302"><td class="memTemplParams" colspan="2">template&lt;int8_t _NF&gt; </td></tr>
<tr class="memitem:adfa277fb8de13ef075c2f01048b0b302"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NF, _NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#adfa277fb8de13ef075c2f01048b0b302">inv</a> () const</td></tr>
<tr class="separator:adfa277fb8de13ef075c2f01048b0b302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89807c8de3c6f82ef6c2f65b2903bc95"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NF, FixMathPrivate::FM_min(NI *2+NF, 64-NF)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a89807c8de3c6f82ef6c2f65b2903bc95">invFull</a> () const</td></tr>
<tr class="separator:a89807c8de3c6f82ef6c2f65b2903bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cbf1c2c1d3096dbe079b09feacebb0"><td class="memTemplParams" colspan="2">template&lt;int8_t _NF = FixMathPrivate::FM_min(NI*2+NF-1,64-NF)&gt; </td></tr>
<tr class="memitem:a85cbf1c2c1d3096dbe079b09feacebb0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NF, _NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a85cbf1c2c1d3096dbe079b09feacebb0">invAccurate</a> () const</td></tr>
<tr class="separator:a85cbf1c2c1d3096dbe079b09feacebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e656ca44e325c3f384917d53a7882d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a38e656ca44e325c3f384917d53a7882d">operator&gt;&gt;</a> (const int8_t op) const</td></tr>
<tr class="separator:a38e656ca44e325c3f384917d53a7882d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9835b0be256af62795f14aa454a1ab0c"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:a9835b0be256af62795f14aa454a1ab0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; FixMathPrivate::FM_max(NI-op, 0), NF+op, FixMathPrivate::rangeShift(NI, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a9835b0be256af62795f14aa454a1ab0c">sR</a> () const</td></tr>
<tr class="separator:a9835b0be256af62795f14aa454a1ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add741555c674d50504ae2999080c80e1"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:add741555c674d50504ae2999080c80e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI+op, FixMathPrivate::FM_max(NF-op, 0), FixMathPrivate::rangeShift(NF, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#add741555c674d50504ae2999080c80e1">sL</a> () const</td></tr>
<tr class="separator:add741555c674d50504ae2999080c80e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd4204bb434debae918c859da069012"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:addd4204bb434debae918c859da069012"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#addd4204bb434debae918c859da069012">operator&gt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:addd4204bb434debae918c859da069012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a55813939a59bc8840315de126bfe50"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a8a55813939a59bc8840315de126bfe50"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a8a55813939a59bc8840315de126bfe50">operator&lt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a8a55813939a59bc8840315de126bfe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66992644d158a7efeb8e521497a3a13"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:ae66992644d158a7efeb8e521497a3a13"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae66992644d158a7efeb8e521497a3a13">operator==</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:ae66992644d158a7efeb8e521497a3a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170d50e511f622186082af600e069609"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a170d50e511f622186082af600e069609"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a170d50e511f622186082af600e069609">operator!=</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a170d50e511f622186082af600e069609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d368e0eca82acd2e8088d4fe6114af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#ad3d368e0eca82acd2e8088d4fe6114af">asSFix</a> () const</td></tr>
<tr class="separator:ad3d368e0eca82acd2e8088d4fe6114af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaabe601fa4fa53d39ef5026f644d36f"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#aeaabe601fa4fa53d39ef5026f644d36f">asFloat</a> () const</td></tr>
<tr class="separator:aeaabe601fa4fa53d39ef5026f644d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bfc5596616a080c133a7075ba1815b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structIntegerType.html">IntegerType</a>&lt; FixMathPrivate::uBitsToBytes(NI)&gt;::unsigned_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a72bfc5596616a080c133a7075ba1815b">asInt</a> () const</td></tr>
<tr class="separator:a72bfc5596616a080c133a7075ba1815b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390542b7d93844ec88b66c6827775e81"><td class="memItemLeft" align="right" valign="top">constexpr internal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a390542b7d93844ec88b66c6827775e81">asRaw</a> () const</td></tr>
<tr class="separator:a390542b7d93844ec88b66c6827775e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:addb9e008fc41495e651b03c77aed89d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:addb9e008fc41495e651b03c77aed89d0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#addb9e008fc41495e651b03c77aed89d0">fromRaw</a> (T raw)</td></tr>
<tr class="separator:addb9e008fc41495e651b03c77aed89d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a66aaaeed2e67163f2bc8bbf2ce08"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#aa17a66aaaeed2e67163f2bc8bbf2ce08">getNI</a> ()</td></tr>
<tr class="separator:aa17a66aaaeed2e67163f2bc8bbf2ce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f594b8b95f377fff38c49f5149866"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a900f594b8b95f377fff38c49f5149866">getNF</a> ()</td></tr>
<tr class="separator:a900f594b8b95f377fff38c49f5149866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed462de594b84eb5c816cdbd7dca1d4"><td class="memItemLeft" align="right" valign="top">static constexpr int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a7ed462de594b84eb5c816cdbd7dca1d4">getRANGE</a> ()</td></tr>
<tr class="separator:a7ed462de594b84eb5c816cdbd7dca1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce7ec1619e8b6d158e69ad437168c3"><td class="memTemplParams" colspan="2">template&lt;int8_t BITS&gt; </td></tr>
<tr class="memitem:a4cce7ec1619e8b6d158e69ad437168c3"><td class="memTemplItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a4cce7ec1619e8b6d158e69ad437168c3">assertSize</a> ()</td></tr>
<tr class="separator:a4cce7ec1619e8b6d158e69ad437168c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a88aee1f9a32079b217a8a393dcd992b7"><td class="memTemplParams" colspan="2"><a id="a88aee1f9a32079b217a8a393dcd992b7"></a>
template&lt;int8_t , int8_t , uint64_t &gt; </td></tr>
<tr class="memitem:a88aee1f9a32079b217a8a393dcd992b7"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SFix</b></td></tr>
<tr class="separator:a88aee1f9a32079b217a8a393dcd992b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt;<br />
class UFix&lt; NI, NF, RANGE &gt;</h3>

<p>Instanciate an unsigned fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NI</td><td>The number of bits encoding the integer part. The integral part can range into [0, 2^NI -1] </td></tr>
    <tr><td class="paramname">NF</td><td>The number of bits encoding the fractional part </td></tr>
    <tr><td class="paramname">RANGE</td><td>A purely internal parameter that keeps track of the range used by the type. Safer to <em>not</em> define it. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7d909dea6bd0d94f1e159450f46df265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d909dea6bd0d94f1e159450f46df265">&#9670;&nbsp;</a></span>UFix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a432caf716e07f7d69e8f06b49b0dc477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432caf716e07f7d69e8f06b49b0dc477">&#9670;&nbsp;</a></span>UFix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a positive floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="a58949c734f134faf346be3f7379f4ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58949c734f134faf346be3f7379f4ed8">&#9670;&nbsp;</a></span>UFix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="a7390119d769ae15f450a5d4fefb50d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7390119d769ae15f450a5d4fefb50d32">&#9670;&nbsp;</a></span>UFix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as_raw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from an integer value which can be interpreted as both a resulting fixed point math number with a fractional part equals to 0, or as a number with decimal, ie as the underlying type behind the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer value </td></tr>
    <tr><td class="paramname">as_raw=false</td><td>with false value will be interpreted as an integer, with true it will be interpreted as a number with decimals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="ae17e095fb2fa03aa8f4d3e61643edcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17e095fb2fa03aa8f4d3e61643edcf4">&#9670;&nbsp;</a></span>UFix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>An unsigned fixed type number which value can be represented in this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned fixed type number </dd></dl>

</div>
</div>
<a id="af3838a6723b019a40df100732ec1bd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3838a6723b019a40df100732ec1bd9b">&#9670;&nbsp;</a></span>UFix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>An signed fixed type number which value can be represented in this type: sign is thus discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned fixed type number </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeaabe601fa4fa53d39ef5026f644d36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaabe601fa4fa53d39ef5026f644d36f">&#9670;&nbsp;</a></span>asFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value as floating point number. </p><dl class="section return"><dt>Returns</dt><dd>The floating point value. </dd></dl>

</div>
</div>
<a id="a72bfc5596616a080c133a7075ba1815b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bfc5596616a080c133a7075ba1815b">&#9670;&nbsp;</a></span>asInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structIntegerType.html">IntegerType</a>&lt;FixMathPrivate::uBitsToBytes(NI)&gt;::unsigned_type <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the integer part of the number, as a standard C type integer (uint8_t, uint16_t etc) depending on NI. </p><dl class="section return"><dt>Returns</dt><dd>The integer part, as a C integer type. </dd></dl>

</div>
</div>
<a id="a390542b7d93844ec88b66c6827775e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390542b7d93844ec88b66c6827775e81">&#9670;&nbsp;</a></span>asRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal_type <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the internal integer value </p><dl class="section return"><dt>Returns</dt><dd>the internal value </dd></dl>

</div>
</div>
<a id="a4cce7ec1619e8b6d158e69ad437168c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cce7ec1619e8b6d158e69ad437168c3">&#9670;&nbsp;</a></span>assertSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::assertSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check wether this number exceeds the given total size given in bits, and produce a compile time error, otherwise.</p>
<dl class="section note"><dt>Note</dt><dd>In the "sibling" function <a class="el" href="classSFix.html#a59bd681b9d4bfaa3141d9d96e05728a2">SFix::assertSize()</a>, the sign bit is counted as an extra bit, i.e. SFix&lt;8,0&gt;::assertSize&lt;8&gt;() will fail!</dd></dl>
<p>Useful as a mechanism to guard against unexpected bit size inflation. This is a compile-type check and will not incur any flash use or performance penalty.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code" href="FixMath_8h.html#a0dda76ba96e4ae059e3872b080b6c681">toUInt</a>((uint16_t) 42); <span class="comment">// uint16_t is unecessarily large for this value, results in a UFix&lt;16,0&gt;</span></div>
<div class="line"><span class="keyword">auto</span> cubed = a*a*a;             <span class="comment">// therefore, cubed is a UFix&lt;48,0&gt;</span></div>
<div class="line">cubed.assertSize&lt;32&gt;();         <span class="comment">// Oops, already at 48 bits! Should have used a smaller data type, above!</span></div>
<div class="ttc" id="aFixMath_8h_html_a0dda76ba96e4ae059e3872b080b6c681"><div class="ttname"><a href="FixMath_8h.html#a0dda76ba96e4ae059e3872b080b6c681">toUInt</a></div><div class="ttdeci">constexpr UFix&lt; sizeof(T) *8, 0 &gt; toUInt(T val)</div><div class="ttdef"><b>Definition:</b> FixMath.h:722</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad3d368e0eca82acd2e8088d4fe6114af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d368e0eca82acd2e8088d4fe6114af">&#9670;&nbsp;</a></span>asSFix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NI,NF,RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asSFix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number as a <a class="el" href="classSFix.html">SFix</a> of same range and precision. This is more optimized than a cast. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classSFix.html">SFix</a> </dd></dl>

</div>
</div>
<a id="addb9e008fc41495e651b03c77aed89d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9e008fc41495e651b03c77aed89d0">&#9670;&nbsp;</a></span>fromRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::fromRaw </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the internal value of the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The new internal value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An UFixx </dd></dl>

</div>
</div>
<a id="a900f594b8b95f377fff38c49f5149866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f594b8b95f377fff38c49f5149866">&#9670;&nbsp;</a></span>getNF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::getNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the fractional part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the fractional part. </dd></dl>

</div>
</div>
<a id="aa17a66aaaeed2e67163f2bc8bbf2ce08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a66aaaeed2e67163f2bc8bbf2ce08">&#9670;&nbsp;</a></span>getNI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::getNI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the integral part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the integral part. </dd></dl>

</div>
</div>
<a id="a7ed462de594b84eb5c816cdbd7dca1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed462de594b84eb5c816cdbd7dca1d4">&#9670;&nbsp;</a></span>getRANGE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int8_t <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::getRANGE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (absolute) range of the integral part of the number, as far as it can be determined at compile time. The true range of the number will typically be lower than (at most the same as) this, so it is not recommended to use this in computations. Available with #define FIXMATH_DEBUG </p><dl class="section return"><dt>Returns</dt><dd>The range of the number </dd></dl>

</div>
</div>
<a id="adfa277fb8de13ef075c2f01048b0b302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa277fb8de13ef075c2f01048b0b302">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NF,_NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a UFix&lt;NF,_NF&gt;. _NF is the number of precision bits for the output. Can be any number but especially useful for case between <a class="el" href="classUFix.html#aa958c40d69f0926ea9d0ee187ed16006">invFast()</a> (_NF=NI) and <a class="el" href="classUFix.html#a89807c8de3c6f82ef6c2f65b2903bc95">invFull()</a> (_NF=2*NI+NF) </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a85cbf1c2c1d3096dbe079b09feacebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cbf1c2c1d3096dbe079b09feacebb0">&#9670;&nbsp;</a></span>invAccurate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NF = FixMathPrivate::FM_min(NI*2+NF-1,64-NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NF,_NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::invAccurate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a <a class="el" href="classUFix.html">UFix</a>&lt;NF,NI*2+NF-1&gt; (default) or as a UFix&lt;NF,_NF&gt; with _NF the template parameter of invAccurate&lt;_NF&gt;. </p><dl class="section note"><dt>Note</dt><dd>This uses a number of width NF+_NF+1 internally. If you are seeking for performances, you should try to aim for this number to not require a too big a type internally. For instance UFix&lt;0,16&gt; a; a.invAccurate&lt;16&gt;() will use a 64 bits internally whereas a.invAccurate&lt;15&gt;() will only use a 32 bits. It can be called as a.invAccurate() (default) or a.invAccurate&lt;16&gt; for instance. </dd></dl>

</div>
</div>
<a id="aa958c40d69f0926ea9d0ee187ed16006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa958c40d69f0926ea9d0ee187ed16006">&#9670;&nbsp;</a></span>invFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NF,NI&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::invFast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a UFix&lt;NF,NI&gt; (not a typo). This inverse is able to represent accurately the inverse of the smallest and biggest of the initial number, but might lead to a lot of duplicates in between. Good if precision is not a premium but type conservation and speeds are. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a89807c8de3c6f82ef6c2f65b2903bc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89807c8de3c6f82ef6c2f65b2903bc95">&#9670;&nbsp;</a></span>invFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NF,FixMathPrivate::FM_min(NI*2+NF,64-NF)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::invFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a <a class="el" href="classUFix.html">UFix</a>&lt;NF,NI*2+NF&gt;. This inverse is more accurate than invFast, and usually leads to non common values on the whole input range. This comes at the cost of a way bigger resulting type. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a170d50e511f622186082af600e069609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170d50e511f622186082af600e069609">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this not equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="ae08634f2ec6f686e781e0805aa8c8c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08634f2ec6f686e781e0805aa8c8c69">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication with a <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="ac6d297515c30a6e4f2895a3c73e8aa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d297515c30a6e4f2895a3c73e8aa2f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt;NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="acc26f823f4151d244bce276d8e39c985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc26f823f4151d244bce276d8e39c985">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF), FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with a <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="ae855ab54e2b28c755c41ad0941fbe33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae855ab54e2b28c755c41ad0941fbe33a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">FixMathPrivate::UFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF), FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="a20414eb474cfb24b9c0da72ce507d5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20414eb474cfb24b9c0da72ce507d5fe">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">SFix</a>&lt;NI,NF,RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite of the number (unary minus operator). </p><dl class="section return"><dt>Returns</dt><dd>The opposite number as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="aefe821e3f4919ee8407aac4ef4ae6cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe821e3f4919ee8407aac4ef4ae6cb1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF), FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction between a <a class="el" href="classUFix.html">UFix</a> and a <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
    <tr><td class="paramname">op2</td><td>A <a class="el" href="classSFix.html">SFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction of op1 by op2. As a <a class="el" href="classSFix.html">SFix</a> </dd></dl>

</div>
</div>
<a id="a59470679dbbaa691a12b09554195fd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59470679dbbaa691a12b09554195fd45">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSFix.html">FixMathPrivate::SFixByRange_t</a>&lt;FixMathPrivate::FM_max(NF,_NF), FixMathPrivate::FM_max(FixMathPrivate::shiftR(RANGE,FixMathPrivate::FM_max(NF,_NF)-NF), FixMathPrivate::shiftR(_RANGE,FixMathPrivate::FM_max(NF,_NF)-_NF))&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a8a55813939a59bc8840315de126bfe50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a55813939a59bc8840315de126bfe50">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is smaller than op, false otherwise </dd></dl>

</div>
</div>
<a id="ae66992644d158a7efeb8e521497a3a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66992644d158a7efeb8e521497a3a13">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="addd4204bb434debae918c859da069012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd4204bb434debae918c859da069012">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is bigger than op, false otherwise </dd></dl>

</div>
</div>
<a id="a38e656ca44e325c3f384917d53a7882d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e656ca44e325c3f384917d53a7882d">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const int8_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right shift. This won't overflow but will not leverage on the bits freed by the shift. Better to use .<a class="el" href="classUFix.html#a9835b0be256af62795f14aa454a1ab0c">sR&lt;shift&gt;()</a> if possible instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="add741555c674d50504ae2999080c80e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add741555c674d50504ae2999080c80e1">&#9670;&nbsp;</a></span>sL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;NI+op,FixMathPrivate::FM_max(NF-op,0),FixMathPrivate::rangeShift(NF,op,RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::sL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal left shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of bigger size. </dd></dl>

</div>
</div>
<a id="a9835b0be256af62795f14aa454a1ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9835b0be256af62795f14aa454a1ab0c">&#9670;&nbsp;</a></span>sR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classUFix.html">UFix</a>&lt;FixMathPrivate::FM_max(NI-op,0),NF+op, FixMathPrivate::rangeShift(NI,op,RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::sR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal right shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of smaller size. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FixMath_8h_source.html">FixMath.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
