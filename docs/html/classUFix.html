<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FixMath: UFix&lt; NI, NF, RANGE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FixMath
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classUFix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UFix&lt; NI, NF, RANGE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="FixMath_8h_source.html">FixMath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2eb220196a257e7442f05bf28a1f30a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a2eb220196a257e7442f05bf28a1f30a0">UFix</a> ()</td></tr>
<tr class="separator:a2eb220196a257e7442f05bf28a1f30a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f7766c3ef12fb230dae14610d8aa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a540f7766c3ef12fb230dae14610d8aa5">UFix</a> (float fl)</td></tr>
<tr class="separator:a540f7766c3ef12fb230dae14610d8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d35441a3682343bf4ed0ff20de6c0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a28d35441a3682343bf4ed0ff20de6c0e">UFix</a> (double fl)</td></tr>
<tr class="separator:a28d35441a3682343bf4ed0ff20de6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51352ed6bdc702844d457d8f3c493633"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51352ed6bdc702844d457d8f3c493633"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a51352ed6bdc702844d457d8f3c493633">UFix</a> (T value, bool as_raw=false)</td></tr>
<tr class="separator:a51352ed6bdc702844d457d8f3c493633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb104c522df3cc21ce6e6795107915b"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a3bb104c522df3cc21ce6e6795107915b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a3bb104c522df3cc21ce6e6795107915b">UFix</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;uf)</td></tr>
<tr class="separator:a3bb104c522df3cc21ce6e6795107915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eec9b0a35847a91a6d4d33aa7d57e4f"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a3eec9b0a35847a91a6d4d33aa7d57e4f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a3eec9b0a35847a91a6d4d33aa7d57e4f">UFix</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;uf)</td></tr>
<tr class="separator:a3eec9b0a35847a91a6d4d33aa7d57e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c96efa9e118a2f3aa7a6ad485f6e9"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:af35c96efa9e118a2f3aa7a6ad485f6e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; FixMathPrivate::neededNIExtra(FixMathPrivate::FM_max(NI, _NI), FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)), FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#af35c96efa9e118a2f3aa7a6ad485f6e9">operator+</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:af35c96efa9e118a2f3aa7a6ad485f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1634442e92c5011484b7aad993db5"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a46f1634442e92c5011484b7aad993db5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSFix.html">SFix</a>&lt; FixMathPrivate::neededSNIExtra(FixMathPrivate::FM_max(NI, _NI), FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)), FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF, _NF, RANGE, _RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a46f1634442e92c5011484b7aad993db5">operator+</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a46f1634442e92c5011484b7aad993db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6caecdc9beaf339e8603d65f6ed450f"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:ae6caecdc9beaf339e8603d65f6ed450f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSFix.html">SFix</a>&lt; FixMathPrivate::FM_max(NI, _NI), FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::FM_max(FixMathPrivate::shiftR(RANGE, FixMathPrivate::FM_max(NF, _NF) -NF), FixMathPrivate::shiftR(_RANGE, FixMathPrivate::FM_max(NF, _NF) -_NF))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae6caecdc9beaf339e8603d65f6ed450f">operator-</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:ae6caecdc9beaf339e8603d65f6ed450f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56945aac12ea56ff2ef427f0400d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a0a56945aac12ea56ff2ef427f0400d2b">operator-</a> () const</td></tr>
<tr class="separator:a0a56945aac12ea56ff2ef427f0400d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cb4444b747885646171ec3b61912a6"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:a75cb4444b747885646171ec3b61912a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; FixMathPrivate::neededNIExtra(NI+_NI, NF+_NF, RANGE *_RANGE), NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a75cb4444b747885646171ec3b61912a6">operator*</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:a75cb4444b747885646171ec3b61912a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0137b8eddb50781aee6b130f6bc948"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </td></tr>
<tr class="memitem:adb0137b8eddb50781aee6b130f6bc948"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSFix.html">SFix</a>&lt; FixMathPrivate::neededSNIExtra(NI+_NI, NF+_NF, RANGE *_RANGE), NF+_NF, RANGE *_RANGE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#adb0137b8eddb50781aee6b130f6bc948">operator*</a> (const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;op) const</td></tr>
<tr class="separator:adb0137b8eddb50781aee6b130f6bc948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc6029f1bfa28cf2a988b82bcd8121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; NF, NI &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a76fc6029f1bfa28cf2a988b82bcd8121">invFast</a> () const</td></tr>
<tr class="separator:a76fc6029f1bfa28cf2a988b82bcd8121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da9bf0d3311e8120281c00d80b88d9"><td class="memTemplParams" colspan="2">template&lt;int8_t _NF&gt; </td></tr>
<tr class="memitem:ae4da9bf0d3311e8120281c00d80b88d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; NF, _NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae4da9bf0d3311e8120281c00d80b88d9">inv</a> () const</td></tr>
<tr class="separator:ae4da9bf0d3311e8120281c00d80b88d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0ef3b9bb633d3ddf3d8bc5b0added3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; NF, FixMathPrivate::FM_min(NI *2+NF, 63-NF)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a6d0ef3b9bb633d3ddf3d8bc5b0added3">invAccurate</a> () const</td></tr>
<tr class="separator:a6d0ef3b9bb633d3ddf3d8bc5b0added3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb7291e4600a247de8f72a111ac4f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#acfb7291e4600a247de8f72a111ac4f1b">operator&gt;&gt;</a> (const int8_t op) const</td></tr>
<tr class="separator:acfb7291e4600a247de8f72a111ac4f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f2f8a0f31805a834e5e1597e74afe8"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:a63f2f8a0f31805a834e5e1597e74afe8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; FixMathPrivate::FM_max(NI-op, 0), NF+op, FixMathPrivate::rangeShift(NI, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a63f2f8a0f31805a834e5e1597e74afe8">sR</a> ()</td></tr>
<tr class="separator:a63f2f8a0f31805a834e5e1597e74afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8238fa9f2b1e69b90e98b845de4a3e2b"><td class="memTemplParams" colspan="2">template&lt;int8_t op&gt; </td></tr>
<tr class="memitem:a8238fa9f2b1e69b90e98b845de4a3e2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUFix.html">UFix</a>&lt; NI+op, FixMathPrivate::FM_max(NF-op, 0), FixMathPrivate::rangeShift(NF, op, RANGE)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a8238fa9f2b1e69b90e98b845de4a3e2b">sL</a> ()</td></tr>
<tr class="separator:a8238fa9f2b1e69b90e98b845de4a3e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbf846ae315eea42ef76e5360c395ea"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:aadbf846ae315eea42ef76e5360c395ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#aadbf846ae315eea42ef76e5360c395ea">operator&gt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:aadbf846ae315eea42ef76e5360c395ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3565c2809ba2c8c5aa1e5d195cc4053b"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:a3565c2809ba2c8c5aa1e5d195cc4053b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a3565c2809ba2c8c5aa1e5d195cc4053b">operator&lt;</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:a3565c2809ba2c8c5aa1e5d195cc4053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55e909b1b7b13c3316cce52fb7c43d0"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:ae55e909b1b7b13c3316cce52fb7c43d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#ae55e909b1b7b13c3316cce52fb7c43d0">operator==</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:ae55e909b1b7b13c3316cce52fb7c43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf7c51e7eda70d8f43bbdf988061bdb"><td class="memTemplParams" colspan="2">template&lt;int8_t _NI, int8_t _NF&gt; </td></tr>
<tr class="memitem:acaf7c51e7eda70d8f43bbdf988061bdb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#acaf7c51e7eda70d8f43bbdf988061bdb">operator!=</a> (const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;op) const</td></tr>
<tr class="separator:acaf7c51e7eda70d8f43bbdf988061bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221fe9e3a32788353b33c9fc90ea8e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSFix.html">SFix</a>&lt; NI, NF, RANGE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a221fe9e3a32788353b33c9fc90ea8e81">asSFix</a> () const</td></tr>
<tr class="separator:a221fe9e3a32788353b33c9fc90ea8e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f54ff6dbaa760abc1bee57b1a762f53"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a3f54ff6dbaa760abc1bee57b1a762f53">asFloat</a> () const</td></tr>
<tr class="separator:a3f54ff6dbaa760abc1bee57b1a762f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad19493943907de03f671a3d0adadcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIntegerType.html">IntegerType</a>&lt; FixMathPrivate::uBitsToBytes(NI)&gt;::unsigned_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#a4ad19493943907de03f671a3d0adadcd">asInt</a> () const</td></tr>
<tr class="separator:a4ad19493943907de03f671a3d0adadcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc319d2451f6fbc58a16004bcf6479c"><td class="memItemLeft" align="right" valign="top">internal_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#adbc319d2451f6fbc58a16004bcf6479c">asRaw</a> () const</td></tr>
<tr class="separator:adbc319d2451f6fbc58a16004bcf6479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb055a1c325c11e80c75b2339128310f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#afb055a1c325c11e80c75b2339128310f">getNI</a> () const</td></tr>
<tr class="separator:afb055a1c325c11e80c75b2339128310f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f95f0bc5ef057ecfae6e605e732ac0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFix.html#ad0f95f0bc5ef057ecfae6e605e732ac0">getNF</a> () const</td></tr>
<tr class="separator:ad0f95f0bc5ef057ecfae6e605e732ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3d9707ef69bacf1316c9c01788a5555a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d9707ef69bacf1316c9c01788a5555a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUFix.html#a3d9707ef69bacf1316c9c01788a5555a">fromRaw</a> (T raw)</td></tr>
<tr class="separator:a3d9707ef69bacf1316c9c01788a5555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt;<br />
class UFix&lt; NI, NF, RANGE &gt;</h3>

<p>Instanciate an unsigned fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NI</td><td>The number of bits encoding the integer part. The integral part can range into [0, 2^NI -1] </td></tr>
    <tr><td class="paramname">NF</td><td>The number of bits encoding the fractional part </td></tr>
    <tr><td class="paramname">RANGE</td><td>A purely internal parameter that keeps track of the range used by the type. Safer to <em>not</em> define it. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2eb220196a257e7442f05bf28a1f30a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb220196a257e7442f05bf28a1f30a0">&#9670;&nbsp;</a></span>UFix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a540f7766c3ef12fb230dae14610d8aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f7766c3ef12fb230dae14610d8aa5">&#9670;&nbsp;</a></span>UFix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a positive floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="a28d35441a3682343bf4ed0ff20de6c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d35441a3682343bf4ed0ff20de6c0e">&#9670;&nbsp;</a></span>UFix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a floating point value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Floating point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="a51352ed6bdc702844d457d8f3c493633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51352ed6bdc702844d457d8f3c493633">&#9670;&nbsp;</a></span>UFix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as_raw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from an integer value which can be interpreted as both a resulting fixed point math number with a fractional part equals to 0, or as a number with decimal, ie as the underlying type behind the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer value </td></tr>
    <tr><td class="paramname">as_raw=false</td><td>with false value will be interpreted as an integer, with true it will be interpreted as a number with decimals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned fixed point number </dd></dl>

</div>
</div>
<a id="a3bb104c522df3cc21ce6e6795107915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb104c522df3cc21ce6e6795107915b">&#9670;&nbsp;</a></span>UFix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>An unsigned fixed type number which value can be represented in this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned fixed type number </dd></dl>

</div>
</div>
<a id="a3eec9b0a35847a91a6d4d33aa7d57e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eec9b0a35847a91a6d4d33aa7d57e4f">&#9670;&nbsp;</a></span>UFix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::<a class="el" href="classUFix.html">UFix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a <a class="el" href="classSFix.html">SFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uf</td><td>An signed fixed type number which value can be represented in this type: sign is thus discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned fixed type number </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f54ff6dbaa760abc1bee57b1a762f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f54ff6dbaa760abc1bee57b1a762f53">&#9670;&nbsp;</a></span>asFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value as floating point number. </p><dl class="section return"><dt>Returns</dt><dd>The floating point value. </dd></dl>

</div>
</div>
<a id="a4ad19493943907de03f671a3d0adadcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad19493943907de03f671a3d0adadcd">&#9670;&nbsp;</a></span>asInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIntegerType.html">IntegerType</a>&lt;FixMathPrivate::uBitsToBytes(NI)&gt;::unsigned_type <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the integer part of the number, as a standard C type integer (uint8_t, uint16_t etc) depending on NI. </p><dl class="section return"><dt>Returns</dt><dd>The integer part, as a C integer type. </dd></dl>

</div>
</div>
<a id="adbc319d2451f6fbc58a16004bcf6479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc319d2451f6fbc58a16004bcf6479c">&#9670;&nbsp;</a></span>asRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal_type <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the internal integer value </p><dl class="section return"><dt>Returns</dt><dd>the internal value </dd></dl>

</div>
</div>
<a id="a221fe9e3a32788353b33c9fc90ea8e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221fe9e3a32788353b33c9fc90ea8e81">&#9670;&nbsp;</a></span>asSFix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF,RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::asSFix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number as a <a class="el" href="classSFix.html">SFix</a> of same range and precision. This is more optimized than a cast. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classSFix.html">SFix</a> </dd></dl>

</div>
</div>
<a id="a3d9707ef69bacf1316c9c01788a5555a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9707ef69bacf1316c9c01788a5555a">&#9670;&nbsp;</a></span>fromRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::fromRaw </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the internal value of the fixed point math number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The new internal value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An UFixx </dd></dl>

</div>
</div>
<a id="ad0f95f0bc5ef057ecfae6e605e732ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f95f0bc5ef057ecfae6e605e732ac0">&#9670;&nbsp;</a></span>getNF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::getNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the fractional part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the fractional part. </dd></dl>

</div>
</div>
<a id="afb055a1c325c11e80c75b2339128310f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb055a1c325c11e80c75b2339128310f">&#9670;&nbsp;</a></span>getNI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::getNI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of bits used to encode the integral part. </p><dl class="section return"><dt>Returns</dt><dd>The number of bits used to encode the integral part. </dd></dl>

</div>
</div>
<a id="ae4da9bf0d3311e8120281c00d80b88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da9bf0d3311e8120281c00d80b88d9">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;NF,_NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a UFix&lt;NF,_NF&gt;. _NF is the number of precision bits for the output. Can be any number but especially useful for case between <a class="el" href="classUFix.html#a76fc6029f1bfa28cf2a988b82bcd8121">invFast()</a> (_NF=NI) and <a class="el" href="classUFix.html#a6d0ef3b9bb633d3ddf3d8bc5b0added3">invAccurate()</a> (_NF=2*NI+NF) </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a6d0ef3b9bb633d3ddf3d8bc5b0added3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0ef3b9bb633d3ddf3d8bc5b0added3">&#9670;&nbsp;</a></span>invAccurate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;NF,FixMathPrivate::FM_min(NI*2+NF,63-NF)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::invAccurate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a <a class="el" href="classUFix.html">UFix</a>&lt;NF,NI*2+NF&gt;. This inverse is more accurate than invFast, and usually leads to non common values on the whole input range. This comes at the cost of a way bigger resulting type. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="a76fc6029f1bfa28cf2a988b82bcd8121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc6029f1bfa28cf2a988b82bcd8121">&#9670;&nbsp;</a></span>invFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;NF,NI&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::invFast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of a UFix&lt;NI,NF&gt;, as a UFix&lt;NF,NI&gt; (not a typo). This inverse is able to represent accurately the inverse of the smallest and biggest of the initial number, but might lead to a lot of duplicates in between. Good if precision is not a premium but type conservation and speeds are. This is still slower than a multiplication, hence the suggested workflow is to compute the inverse when time is not critical, for instance in updateControl(), and multiply it afterward, for instance in updateAudio(), if you need a division. </p><dl class="section return"><dt>Returns</dt><dd>The inverse of the number. </dd></dl>

</div>
</div>
<a id="acaf7c51e7eda70d8f43bbdf988061bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf7c51e7eda70d8f43bbdf988061bdb">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this not equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="adb0137b8eddb50781aee6b130f6bc948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0137b8eddb50781aee6b130f6bc948">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFix.html">SFix</a>&lt;FixMathPrivate::neededSNIExtra(NI+_NI, NF+_NF, RANGE*_RANGE),NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication with a <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classSFix.html">SFix</a> to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a75cb4444b747885646171ec3b61912a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cb4444b747885646171ec3b61912a6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;FixMathPrivate::neededNIExtra(NI+_NI, NF+_NF, RANGE*_RANGE),NF+_NF, RANGE*_RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="a46f1634442e92c5011484b7aad993db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f1634442e92c5011484b7aad993db5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFix.html">SFix</a>&lt;FixMathPrivate::neededSNIExtra(FixMathPrivate::FM_max(NI,_NI),FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)),FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSFix.html">SFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with a <a class="el" href="classSFix.html">SFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="af35c96efa9e118a2f3aa7a6ad485f6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c96efa9e118a2f3aa7a6ad485f6e9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;FixMathPrivate::neededNIExtra(FixMathPrivate::FM_max(NI,_NI),FixMathPrivate::FM_max(NF,_NF),FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)),FixMathPrivate::FM_max(NF, _NF), FixMathPrivate::rangeAdd(NF,_NF,RANGE,_RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="a0a56945aac12ea56ff2ef427f0400d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a56945aac12ea56ff2ef427f0400d2b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFix.html">SFix</a>&lt;NI,NF,RANGE&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite of the number. </p><dl class="section return"><dt>Returns</dt><dd>The opposite number as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="ae6caecdc9beaf339e8603d65f6ed450f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6caecdc9beaf339e8603d65f6ed450f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF, uint64_t _RANGE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSFix.html">SFix</a>&lt;FixMathPrivate::FM_max(NI,_NI),FixMathPrivate::FM_max(NF,_NF), FixMathPrivate::FM_max(FixMathPrivate::shiftR(RANGE,FixMathPrivate::FM_max(NF,_NF)-NF), FixMathPrivate::shiftR(_RANGE,FixMathPrivate::FM_max(NF,_NF)-_NF))&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF, _RANGE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction with another <a class="el" href="classUFix.html">UFix</a>. Safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classUFix.html">UFix</a> to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction as a <a class="el" href="classSFix.html">SFix</a>. </dd></dl>

</div>
</div>
<a id="a3565c2809ba2c8c5aa1e5d195cc4053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3565c2809ba2c8c5aa1e5d195cc4053b">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is smaller than op, false otherwise </dd></dl>

</div>
</div>
<a id="ae55e909b1b7b13c3316cce52fb7c43d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e909b1b7b13c3316cce52fb7c43d0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this equal to op, false otherwise </dd></dl>

</div>
</div>
<a id="aadbf846ae315eea42ef76e5360c395ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbf846ae315eea42ef76e5360c395ea">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t _NI, int8_t _NF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUFix.html">UFix</a>&lt; _NI, _NF &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison with another <a class="el" href="classUFix.html">UFix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A <a class="el" href="classUFix.html">UFix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is bigger than op, false otherwise </dd></dl>

</div>
</div>
<a id="acfb7291e4600a247de8f72a111ac4f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb7291e4600a247de8f72a111ac4f1b">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;NI,NF&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const int8_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right shift. This won't overflow but will not leverage on the bits freed by the shift. Better to use .<a class="el" href="classUFix.html#a63f2f8a0f31805a834e5e1597e74afe8">sR&lt;shift&gt;()</a> if possible instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a>. </dd></dl>

</div>
</div>
<a id="a8238fa9f2b1e69b90e98b845de4a3e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8238fa9f2b1e69b90e98b845de4a3e2b">&#9670;&nbsp;</a></span>sL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;NI+op,FixMathPrivate::FM_max(NF-op,0),FixMathPrivate::rangeShift(NF,op,RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::sL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal left shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of bigger size. </dd></dl>

</div>
</div>
<a id="a63f2f8a0f31805a834e5e1597e74afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f2f8a0f31805a834e5e1597e74afe8">&#9670;&nbsp;</a></span>sR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t NI, int8_t NF, uint64_t RANGE = FixMathPrivate::uFullRange(NI+NF)&gt; </div>
<div class="memtemplate">
template&lt;int8_t op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUFix.html">UFix</a>&lt;FixMathPrivate::FM_max(NI-op,0),NF+op, FixMathPrivate::rangeShift(NI,op,RANGE)&gt; <a class="el" href="classUFix.html">UFix</a>&lt; NI, NF, RANGE &gt;::sR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe and optimal right shift. The returned type will be adjusted accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The shift number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the shift as a <a class="el" href="classUFix.html">UFix</a> of smaller size. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FixMath_8h_source.html">FixMath.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
